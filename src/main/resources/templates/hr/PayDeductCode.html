<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org"
	xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
	layout:decorate="~{layout/base}">
<head>
<title layout:fragment="title">공제 등록</title>


<meta name="_csrf" th:content="${_csrf?.token}">
<meta name="_csrf_header" th:content="${_csrf?.headerName}">

<th:block layout:fragment="head_extra">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/npm/ag-grid-community@31.3.1/styles/ag-grid.css" />
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/npm/ag-grid-community@31.3.1/styles/ag-theme-quartz.css" />
	<style>
#deductGrid.ag-theme-quartz {
	height: 44rem;
	width: 100%;
	margin-top: .5rem;
}

.btn-use {
	padding: .2rem .6rem;
	font-size: 12px;
}
</style>
</th:block>
</head>
<body>
	<section layout:fragment="content">
		<div class="card shadow mb-3">
			<div
				class="card-header py-3 d-flex align-items-center justify-content-between">
				<h6 class="m-0 font-weight-bold text-primary">공제 등록</h6>
			</div>
			<div class="card-body">
			    <div id="deductGridWrapper" style="position:relative;">	
				<div id="deductGrid" class="ag-theme-quartz"></div>
				</div>
			</div>
		</div>
	</section>

	<th:block layout:fragment="body_extra">
		<script
			src="https://cdn.jsdelivr.net/npm/ag-grid-community@31.3.1/dist/ag-grid-community.min.js"></script>
		<script
			src="https://cdn.jsdelivr.net/npm/axios@1.7.7/dist/axios.min.js"></script>
		<script th:inline="none">
(() => { 
  // - ag-Grid를 초기화하고, axios로 백엔드 REST API를 호출합니다.
  // - 맨 아래 onGridReady에서 최초 데이터를 불러오고, 맨 끝에 입력용 한 줄을 추가해요.

  let gridApi;                           // // 그리드 조작을 위한 API
  const API_BASE = '/api/hr/deduct-codes'; // // 공제코드 관련 백엔드 기본 

  //  CSRF 헤더 기본 설정 
  (function initCsrf(){
    try{
      const token  = document.querySelector('meta[name="_csrf"]')?.content;
      const header = document.querySelector('meta[name="_csrf_header"]')?.content || 'X-CSRF-TOKEN';
      if (token) axios.defaults.headers.common[header] = token;
    }catch(e){ }
  })();

  // 응답 성공 
  const isOk = (res) => {
    const s = res?.status ?? 0;
    if (s >= 200 && s < 300) return true;      
    const d = res?.data;
    return d === 1 || d === '1' || d === true || d?.success === true;
  };

  //유틸
  const trim = (v) => (v ?? '').toString().trim();     // 문자열 공백 제거
  const isBlank = (v) => trim(v) === '';               // 비어있으면 true

  function newInputRow(){
    // 화면 맨 아래 "신규 입력 전용" 행을 하나 만들어 줍니다.
    return { _isInput:true, deductCode:'', deductName:'', formulaTxt:'', methodDesc:'', useYn:'Y' };
  }
  const isInsertSavable = (r) => r?._isInput && !isBlank(r.deductCode) && !isBlank(r.deductName); // 입력행 저장 가능 조건
  const isUpdateSavable = (r) => !r?._isInput && !isBlank(r.deductCode) && !isBlank(r.deductName); //기존행 수정 가능 조건

  //  API 
  async function fetchList(){
	  showLoader("deductGridWrapper", "공제 데이터를 불러오는 중입니다...");
	  try {
	    const res = await axios.get(API_BASE);
	    if (!isOk(res)) return [];
	    //  응답이 배열이면 그대로, 아니면 data.data 같은 형태를 유연하게 수용
	    return Array.isArray(res.data) ? res.data : (res.data?.data ?? []);
	  } catch (e) {
	    console.error('공제 목록 조회 실패', e);
	    alert('공제 목록 조회 중 오류가 발생했습니다.');
	    return [];
	  } finally {
	    hideLoader("deductGridWrapper");
	  }
	}

  async function insertRow(r){
    //신규 입력행을 서버로 전송(POST). 코드/이름은 필수.
    const payload = {
      deductCode: trim(r.deductCode),
      deductName: trim(r.deductName),
      formulaTxt: trim(r.formulaTxt),
      methodDesc: trim(r.methodDesc),
      useYn:      trim(r.useYn || 'Y')
    };
    const res = await axios.post(API_BASE, payload, { validateStatus:s=>s>=200&&s<500 });
    return isOk(res);
  }

  async function updateRow(r){
    //기존 행 수정(PUT). PK=dccutCode는 URL 경로로 보냅니다.
    const payload = {
      deductName: trim(r.deductName),
      formulaTxt: trim(r.formulaTxt),
      methodDesc: trim(r.methodDesc),
      useYn:      trim(r.useYn || 'Y')
    };
    const res = await axios.put(`${API_BASE}/${encodeURIComponent(r.deductCode)}`, payload, { validateStatus:s=>s>=200&&s<500 });
    return isOk(res);
  }

  async function patchUseYn(code, yn){
    // 사용/중지 토글(PATCH).
    const res = await axios.patch(`${API_BASE}/${encodeURIComponent(code)}/use-yn`, null, {
      params:{ useYn: yn }, validateStatus:s=>s>=200&&s<500
    });
    return isOk(res);
  }

  // 사용/중지 토글 렌더러
  function useToggleRenderer(p){
    if (p.data?._isInput) return document.createTextNode('');
    const btn = document.createElement('button');
    btn.type = 'button';
    const cur = (p.value ?? 'Y');
    // // 현재 상태에 따라 색상/라벨 지정
    btn.className = 'btn btn-sm btn-use ' + (cur === 'Y' ? 'btn-success' : 'btn-danger');
    btn.textContent = (cur === 'Y' ? '사용' : '중지');

    btn.addEventListener('click', async () => {
      // // 버튼 클릭 시 즉시 화면에 토글 반영 → 서버 PATCH 호출 → 실패 시 원복
      const row = p.data;
      const next = (row.useYn ?? 'Y') === 'Y' ? 'N' : 'Y';

      // 화면 즉시 반영
      row.useYn = next;
      btn.className = 'btn btn-sm btn-use ' + (next === 'Y' ? 'btn-success' : 'btn-danger');
      btn.textContent = (next === 'Y' ? '사용' : '중지');

      try{
        const ok = await patchUseYn(row.deductCode, next);
        if(!ok) throw new Error('useYn patch fail');
      }catch(e){
        // 실패 시 원복 + 안내
        const prev = next === 'Y' ? 'N' : 'Y';
        row.useYn = prev;
        btn.className = 'btn btn-sm btn-use ' + (prev === 'Y' ? 'btn-success' : 'btn-danger');
        btn.textContent = (prev === 'Y' ? '사용' : '중지');
        console.error('사용여부 변경 실패', e);
        alert('사용여부 변경 실패');
      }
    });

    return btn;
  }

  // 정렬 후 입력행을 항상 마지막으로 유지
  function keepInputRowAtEnd(params){
    // 사용자가 정렬을 바꿔도 입력행(_isInput)은 목록의 제일 끝으로 보내 안정적 UX 제공
    const nodes = params.nodes;
    const inputNodes = [];
    for(let i = nodes.length - 1; i >= 0; i--){
      const n = nodes[i];
      if(n?.data?._isInput){
        inputNodes.push(n);
        nodes.splice(i,1);
      }
    }
    inputNodes.forEach(n => nodes.push(n));
  }

  document.addEventListener('DOMContentLoaded', async () => {
    // 그리드 컬럼 정의(각 컬럼별 편집 가능 여부/값 세터 등 포함)
    const columnDefs = [
      { headerName:'공제 코드', field:'deductCode', width:120,
        editable:(p)=> p.data?._isInput === true,                              //신규입력행에서만 코드 편집 허용
        valueSetter:(p)=>{ p.data.deductCode = trim(p.newValue).toUpperCase(); return true; } }, // // 코드 입력 시 대문자 변환
      { headerName:'공제 항목 명', field:'deductName', minWidth:160, flex:1, editable:true,
        valueSetter:(p)=>{ p.data.deductName = trim(p.newValue); return true; } },
      { headerName:'계산식', field:'formulaTxt', minWidth:220, flex:1.2, editable:true,
        valueSetter:(p)=>{ p.data.formulaTxt = trim(p.newValue); return true; } },
      { headerName:'산출 방법', field:'methodDesc', minWidth:260, flex:1.5, editable:true,
        valueSetter:(p)=>{ p.data.methodDesc = trim(p.newValue); return true; } },
      { headerName:'사용 여부', field:'useYn', width:120,
        editable:(p)=> p.data?._isInput === true,                              // 신규입력행에서는 Y/N 직접 선택 가능
        cellEditor:'agSelectCellEditor', cellEditorParams:{ values:['Y','N'] }, //  입력행 셀렉트 에디터
        cellRenderer: useToggleRenderer },                                     // 기존행은 토글 버튼 표시
    ];

    // // ag-Grid 옵션(페이징/정렬/편집/이벤트 등)
    const gridOptions = {
      columnDefs,
      rowData: [],
      pagination:true,
      paginationPageSize:20,
      defaultColDef:{ resizable:true, filter:false, sortable:true },
      editType:'fullRow',                                // 한 행 단위로 편집(엔터로 저장 트리거)
      singleClickEdit:true,                              // 한 번 클릭으로 편집 시작
      stopEditingWhenCellsLoseFocus:true,                //  포커스 벗어나면 편집종료
      sortModel:[{ colId:'deductCode', sort:'asc' }],    // 기본 정렬: 코드 오름차순
      postSortRows: keepInputRowAtEnd,                   //  정렬 후 입력행을 맨 뒤로 유지

      // Enter로 편집 종료 → 저장 트리거
      onCellKeyDown: (ev) => {
        if (ev.event?.key === 'Enter') ev.api.stopEditing();
      },

      // 행 편집 종료 시 자동 저장
      onRowValueChanged: async (ev) => {
        const d = ev.data;
        try {
          if (isInsertSavable(d)) {
            const ok = await insertRow(d);
            if(!ok) throw new Error('insert fail');
            const rows = await fetchList();
            gridApi.setRowData([...rows, newInputRow()]);
            alert('등록되었습니다.');
          } else if (isUpdateSavable(d)) {
            const ok = await updateRow(d);
            if(!ok) throw new Error('update fail');
            gridApi.refreshClientSideRowModel('sort');
            alert('수정되었습니다.');
          } else {
            if (d?._isInput) alert('코드와 항목명을 입력하세요.');
          }
        } catch(e){
          console.error('저장 실패', e);
          alert('저장 실패: 네트워크/서버 응답을 확인하세요.');
        }
      },


      onGridReady: async (params) => {
        // // 그리드가 준비되면 API 핸들을 보관하고, 서버에서 목록을 가져와 표시합니다.
        gridApi = params.api;
        try{
          const rows = await fetchList();
          // // 화면에 조회된 데이터 + 입력행을 넣습니다.
          gridApi.setRowData([...rows, newInputRow()]);
        }catch(e){
          console.error('초기 로딩 실패', e);
          gridApi.setRowData([newInputRow()]); 
          alert('목록 조회 실패');
        }
      }
    };
    new agGrid.Grid(document.getElementById('deductGrid'), gridOptions);
  });
})();
</script>
	</th:block>
</body>
</html>
