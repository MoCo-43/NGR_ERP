<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.yedam.erp.mapper.stock.StockMapper">
<insert id="insertProduct" parameterType="ProductVO">
INSERT INTO product(
		PRODUCT_CODE
		,PRODUCT_NAME
		,SPECIFICATION
		,EMP_NAME
		,PRODUCT_IMAGE
		,PURCHASE_PRICE
		,SALES_PRICE
		,NOTE
		,INSERT_DATE
		,COMPANY_CODE
		,LEAD_TIME
		,VAT_TYPE
)
VALUES(CONCAT('P',LPAD(seq_product.nextval,5,'0')),
       #{productName},
       #{specification},
       #{empName},
       #{productImageName},
       #{purchasePrice},
       #{salesPrice},
       #{note},
       #{insertDate},
       #{companyCode},
       #{leadTime},
       #{vatType}
)

</insert>

<select id="customerAll" resultType="PartnerVO" parameterType="map">
SELECT 
       emp_name, 
       cus_name,
       cus_code,
       biz_no,
       ceo_name, 
       biz_type ,
       biz_category,
       addr 
FROM customer
WHERE gbn = '구매처'
AND company_code = #{compCode}
<if test="cusKw != null and cusKw != ''">
    AND cus_name LIKE '%' || #{cusKw} || '%'
</if>
<if test="empKw != null and empKw != ''">
    AND emp_name LIKE '%' || #{empKw} || '%'
</if>
<if test="btKw != null and btKw != ''">
    AND biz_type LIKE '%' || #{btKw} || '%'
</if>
<if test="bcKw != null and bcKw != ''">
    AND biz_category LIKE '%' || #{bcKw} || '%'
</if>
</select>

<select id="productAll" resultType="ProductVO">
SELECT PRODUCT_CODE
       ,PRODUCT_NAME
       ,SPECIFICATION
       ,VAT_TYPE 
       ,INSERT_DATE 
FROM PRODUCT 
WHERE COMPANY_CODE = #{companyCode}
</select>

<select id="getProductFileNameByProductCodeAndCompCode" resultType="String">
SELECT PRODUCT_IMAGE, PRODUCT_NAME 
FROM PRODUCT 
WHERE PRODUCT_CODE = #{productCode}
  AND COMPANY_CODE = #{compCode} 
</select>


<select id="getProductDetailRefInbound" resultType="InboundVO">
SELECT 
      LOT_CODE
     ,PRODUCT_NAME
     ,SPECIFICATION
     ,BUSINESS_PARTNER
     ,BUSINESS_CODE 
     ,PRODUCT_CODE
     ,PURCHASE_PRICE
     ,REMAIN_QTY
FROM INBOUND 
WHERE COMPANY_CODE = #{companyCode} 
AND PRODUCT_CODE = #{productCode}

</select>


<insert id="insertOrderPlan" parameterType="OrderPlanVO">
<selectKey keyProperty="xpCode" resultType="string" order="BEFORE">
        SELECT CONCAT('OP', SEQ_EXPLAIN.nextval) FROM dual
</selectKey>
INSERT INTO EXPLAIN(
         XP_CODE
         ,EMP_ID
         ,INS_DATE
         ,COMPANY_CODE
)
VALUES (#{xpCode}, #{empId}, #{insDate}, #{companyCode})


</insert>
<insert id="insertOrderPlanDetail" parameterType="OrderPlanDetailVO">
INSERT INTO EXPLAIN_DETAIL(
         XD_NO
        ,PRODUCT_CODE
        ,PRODUCT_NAME
        ,SPECIFICATION
        ,BUSINESS_PARTNER
        ,BUSINESS_CODE
        ,AMOUNT
        ,PURCHASE_PRICE
        ,SUP_AMT
        ,VAT_AMT
        ,XP_CODE
        
)
VALUES (SEQ_EXPLAIN_DETAIL.nextval ,
        #{productCode}, 
        #{productName},
        #{specification}, 
        #{businessPartner},
        #{businessCode},
        #{amount},
        #{purchasePrice},
        #{supAmt},
        #{vatAmt},
        #{xpCode}
        
)


</insert>
<!-- 발주 계획 조회 -->
<select id="selectOrderPlans" resultMap="orderPlanResultMap">
SELECT 
    m.xp_code as "xp_code",
    min(d.business_partner) as "business_partner",
    min(d.business_code) as "business_code",  
    m.emp_id as "emp_id",
    m.vat_type as "vat_type",
    m.ins_date as "ins_date",
    case
        when count(d.xd_no) > 1 
            then min(d.product_name) || ' 외 ' || (count(d.xd_no) - 1) || '건' 
        else min(d.product_name) 
    end as "product_name",
    sum(d.amount) as "amount",
    sum(d.sup_amt) as "sup_amt",
     case 
        when exists (
            select 1 from order_req o 
            where o.xp_code = m.xp_code
        ) then 'Y'
        else 'N'
    end as "has_order_sheet"
   
FROM explain m 
JOIN explain_detail d 
    ON m.xp_code = d.xp_code 
GROUP BY 
    m.xp_code, 
    m.emp_id, 
    m.vat_type,
    m.ins_date
    
ORDER BY TO_NUMBER(SUBSTR(m.xp_code, 3)) DESC
</select>

<!-- ResultMap -->
<resultMap id="orderPlanResultMap" type="OrderPlanVO">
    <id property="xpCode" column="xp_code"/>
    <result property="empId" column="emp_id"/>
    <result property="insDate" column="ins_date"/>
    <result property="vatType" column="vat_type"/>
    <result property="hasOrderSheet" column="has_order_sheet"/> <!-- 추가 -->
    
    <!-- 디테일 매핑 -->
    <collection property="details" ofType="OrderPlanDetailVO" 
        select="selectOrderPlanDetailsByXpCode" column="xp_code"/>
</resultMap>

<!-- 발주 계획 상세 조회 -->
<select id="selectOrderPlanDetailsByXpCode" parameterType="String" resultType="OrderPlanDetailVO">
SELECT 
    xd_no       as xd_no,
    ed.product_code as product_code,
    ed.product_name as product_name,
    ed.specification as specification,
    ed.business_partner as business_partner,
    ed.business_code as business_code,
    ed.amount as amount,
    ed.purchase_price as purchase_price,
    ed.sup_amt as sup_amt,
    ed.vat_amt as vat_amt,
    p.vat_type as vat_type 
FROM explain_detail ed 
JOIN product p
ON ed.product_code = p.product_code 
WHERE xp_code = #{xpCode}
</select>

<!-- 발주서 마스터 조회 -->
<select id="selectOrderByXpCode" resultType="OrderVO" parameterType="String">
    SELECT 
        om.XP_CODE AS xpCode,
        om.CUS_CODE AS businessCode,
        c.CUS_NAME AS cusName,
        om.due_DATE AS dueDate
    FROM order_req om
    JOIN customer c ON om.CUS_CODE = c.CUS_CODE
    WHERE om.XP_CODE = #{xpCode}
</select>

<!-- 발주서 상세 조회 -->
<select id="selectOrderDetailsByXpCode" resultType="OrderDetailVO" parameterType="String">
SELECT 
    od.PRODUCT_CODE AS PRODUCT_CODE,
    od.PRODUCT_NAME AS PRODUCT_NAME,
    od.QTY AS QTY,
    od.ORDER_PRICE AS ORDER_PRICE,
    od.SUP_AMT AS SUP_AMT,
    od.VAT_AMT AS VAT_AMT,
    om.due_date AS DUE_DATE 
FROM order_req om
JOIN order_detail od ON om.ORDER_CODE = od.ORDER_CODE
JOIN customer c ON om.CUS_CODE = c.CUS_CODE
JOIN explain ex ON ex.xp_code = om.xp_code
WHERE om.xp_code = #{xpCode}
ORDER BY od.OD_NO
</select>

<!-- 발주서 세션의 회사정보 조회 -->
<select id="selectComp" resultType="com.yedam.erp.vo.main.CompanyVO" parameterType="Long">
SELECT 
      BRM,
      COMP_NAME,
      CEO,
      COMP_ADDR,
      MAT_NAME,
      MAT_TEL
FROM COMPANY
WHERE MAT_NO = #{compId}
</select>

<!-- 발주서 거래처 정보 조회 -->
<select id="selectCutomer" resultType="com.yedam.erp.vo.Biz.CustomerVO" parameterType="String">
SELECT 
       CUS_NAME, 
       TEL, 
       EMAIL 
FROM CUSTOMER 
WHERE CUS_CODE = #{businessCode}
</select>

<!-- 발주 조회 -->
<select id="getOrderList" resultMap="orderListResultMap">
SELECT
       orr.order_code AS order_code,
       orr.business_partner AS business_partner,
       orr.cus_code AS cus_code,
       orr.emp_id AS emp_id, 
       CASE
         WHEN COUNT(ord.od_no) > 1 
             THEN MIN(ord.product_name) || ' 외 ' || (COUNT(ord.od_no) - 1) || '건' 
         ELSE MIN(ord.product_name) 
       END as "product_name",
       SUM(ord.qty) AS qty,
       orr.due_date AS due_date,
       orr.vat_type AS vat_type,
       sum(ord.sup_amt) AS sup_amt,
       orr.xp_code AS xp_code 
FROM order_req orr
JOIN order_detail ord
ON orr.order_code = ord.order_code
GROUP BY 
    orr.order_code,
    orr.business_partner,
    orr.cus_code,
    orr.emp_id,
    orr.due_date,
    orr.vat_type,
    orr.xp_code
    
<!-- ORDER BY TO_NUMBER(REGEXP_SUBSTR(orr.order_code, '\d+')) DESC -->
ORDER BY orr.order_code DESC

</select>
<resultMap id="orderListResultMap" type="OrderVO">
    <id property="orderCode" column="order_code"/>
    <result property="businessPartner" column="business_partner"/>
    <result property="cusCode" column="cus_code"/>
    <result property="productName" column="product_name"/>
    <result property="empId" column="emp_id"/>
    <result property="amount" column="qty"/>
    <result property="supAmt" column="sup_amt"/>
   	<result property="vatType" column="vat_type"/>
   	<result property="dueDate" column="due_date"/>
    
    <!-- 디테일 매핑 -->
    <collection property="details" ofType="OrderDetailVO" 
        select="getOrderDetailByOrderCode" column="order_code"/>
</resultMap>

<select id="getOrderDetailByOrderCode" resultType="OrderDetailVO">
SELECT 
       ord.product_code AS product_code,
       ord.product_name AS product_name,
       ord.qty AS qty, 
       ord.order_price AS order_price, 
       ord.sup_amt AS sup_amt,
       ord.vat_amt AS vat_amt,
       orr.due_date AS due_date, 
       CASE WHEN SUBSTR(orr.VAT_TYPE,1,1) = '부' THEN 'VAT 포함'
          WHEN SUBSTR(orr.VAT_TYPE,1,1) = '영' THEN '영세율 적용'
          ELSE '면세'
       END AS "taxType" 
FROM order_detail ord 
JOIN order_req orr 
ON orr.order_code = ord.order_code 
WHERE orr.order_code = #{orderCode}
ORDER BY ord.od_no 
</select>

<!-- 발주 등록 - 마스터 테이블 -->
<insert id="insertOrderReq" parameterType="OrderVO">
 <!-- BEFORE: insert 전에 orderCode 생성 -->
<selectKey keyProperty="orderCode" resultType="string" order="BEFORE">
        SELECT 'ORD' || TO_CHAR(SYSDATE,'YYMMDD') || '-' || SEQ_ORDER.nextval FROM dual
</selectKey>
  INSERT INTO order_req (
        order_code
       ,business_partner
       ,cus_code
       ,emp_id
       ,vat_type
       ,due_date
       ,xp_code
       ,company_code
    )
    VALUES (
       #{orderCode}
       ,#{businessPartner}
       ,#{cusCode}
       ,#{empId}
       ,#{vatType}
       ,#{dueDate}
       ,#{xpCode}
       ,#{companyCode}
    )
</insert>

<!-- 발주 등록 - 디테일 테이블 -->
<insert id="insertOrderDetail" parameterType="OrderDetailVO">
INSERT INTO order_detail(
        OD_NO
       ,PRODUCT_CODE
       ,PRODUCT_NAME
       ,SPECIFICATION
       ,QTY
       ,ORDER_PRICE
       ,SUP_AMT
       ,VAT_AMT
       ,NOTE
       ,ORDER_CODE
       ,COMPANY_CODE
)
VALUES (SEQ_ORDER_DETAIL.nextval
        ,#{productCode}
       ,#{productName}
       ,#{specification}
       ,#{qty}
       ,#{orderPrice}
       ,#{supAmt}
       ,#{vatAmt}
       ,#{note}
       ,#{orderCode}
       ,#{companyCode}
)
</insert>

<!-- 결산 조회 - 마스터 -->
<select id="getIcList" resultType="InvenVO" parameterType="Long">
SELECT 
       ic.IC_CODE,  
       ic.IC_DATE, 
       ic.EMP_ID, 
       emp.NAME, 
       CASE WHEN ic.IC_STATUS = 'T' THEN '결재대기'
            ELSE '결재완료' END AS IC_STATUS
      
FROM INVENTORY_CLOSING ic 
LEFT JOIN EMP_LOGIN emp 
ON ic.emp_id = emp.emp_id 
WHERE ic.COMPANY_CODE = #{companyCode}
</select>

<!-- 결산 조회 - 상세 -->
<select id="getIcDetailList" resultType="InvenDetailVO">
SELECT 
       product_code ,
       product_name, 
       opening_stock , 
       stock, 
       valuation_amount
from INVENTORY_CLOSING_DETAIL
WHERE COMPANY_CODE = #{companyCode}
AND IC_CODE = #{icCode}

</select>

<!-- 입고 필터 조회 -->
<select id="selectselectInboundList" parameterType="map" resultType="InboundVO">
    SELECT *
    FROM inbound
    WHERE 1=1
      <if test="compCode != null">
        AND comp_code = #{compCode}
      </if>
      <if test="productCode != null and productCode != ''">
        AND product_code = #{productCode}
      </if>
      <if test="businessPartner != null and businessPartner != ''">
        AND business_partner LIKE CONCAT('%', #{businessPartner}, '%')
      </if>
      <if test="inboundDate != null and inboundDate != ''">
        AND inbound_date = #{inboundDate}
      </if>
      <if test="dueDate != null and dueDate != ''">
        AND due_date = #{dueDate}
      </if>
</select>


<!-- 입고 조회 -->
<select id="getInboundList" resultType="InboundVO" parameterType="Long">
SELECT
       INBOUND_DATE ,
       DUE_DATE ,
       LOT_CODE ,
       BUSINESS_PARTNER , 
       BUSINESS_CODE 
FROM INBOUND 
WHERE COMPANY_CODE = #{compCode}
</select>

<!-- 입고 상세 조회 -->
<select id="getInboundDetail" resultType="InboundVO" parameterType="String">
SELECT
       PRODUCT_CODE
       ,PRODUCT_NAME
       ,SPECIFICATION
       ,BUSINESS_CODE
       ,BUSINESS_PARTNER
       ,QTY
       ,DUE_DATE
       ,PURCHASE_PRICE 	
FROM INBOUND 
WHERE LOT_CODE = #{lotCode}

</select>

<!-- 입고등록용 발주 상세 조회 -->
<select id="getOrderDetailListByOrderCode" resultType="OrderDetailVO" parameterType="String">
SELECT 
    d.product_code AS product_code,
    d.product_name AS product_name,
    d.specification AS specification,
    COALESCE(stock_data.stock_qty, 0) AS stock,  -- 계산된 재고
    SUM(d.qty) AS qty,  -- 발주 수량
    d.company_code AS company_code
    ,d.order_price AS order_price -- 구매단가
FROM order_detail d
LEFT JOIN (
<!-- 재고수량 조회 서브쿼리-->
    SELECT product_code, SUM(stock_qty) AS stock_qty
    FROM (
        -- 입고 합계
        SELECT product_code, SUM(qty) AS stock_qty
        FROM inbound
        GROUP BY product_code

        UNION ALL

        -- 출고 합계 (음수)
        SELECT ob.product_code, -SUM(lo.lot_out_amt) AS stock_qty
        FROM outbound ob
        LEFT JOIN lot_outbound lo
          ON ob.outbound_no = lo.outbound_no
        GROUP BY ob.product_code
    ) t
    GROUP BY product_code
) stock_data
  ON d.product_code = stock_data.product_code
WHERE d.order_code = #{orderCode}
GROUP BY 
    d.product_code, d.product_name, d.specification, 
    d.company_code, stock_data.stock_qty , d.order_price 
ORDER BY d.product_code

</select>
<update id="insertInbound" parameterType="InboundVO">
<!-- 
 MERGE INTO INBOUND t
    USING (SELECT #{orderCode} AS orderCode, #{businessCode} AS businessCode, #{productCode} AS productCode FROM dual) src
    ON (t.orderCode = src.orderCode AND t.productCode = src.productCode AND t.businessCode = src.businessCode)
    WHEN MATCHED THEN
        UPDATE SET
            t.qty = t.qty + #{qty}
    WHEN NOT MATCHED THEN
        INSERT (lot_code, product_code, product_name, specification, qty, inbound_date, note, due_date, company_code, business_partner, cus_code)
        VALUES (#{lotCode}, #{productCode}, #{productName}, #{specification}, #{qty}, sysdate, #{note}, #{dueDate}, #{companyCode}, #{businessPartner}, #{businessCode});
 -->

    DECLARE
        v_lotCode VARCHAR2(30);
    BEGIN
        -- LOT 코드 생성
        v_lotCode := fn_generate_code('LOT',#{productCode});

        -- MERGE 구문: 존재하면 qty 업데이트, 없으면 INSERT
        MERGE INTO INBOUND t
        USING (SELECT  #{businessCode} AS businessCode, #{productCode} AS productCode , TRUNC(SYSDATE) AS inboundDate FROM dual) src
        ON (t.product_code = src.productCode AND t.business_code = src.businessCode AND TRUNC(t.inbound_date) = src.inboundDate)
        WHEN MATCHED THEN
            UPDATE SET t.qty = t.qty + #{qty} , t.remain_qty = t.remain_qty + #{qty} 
        WHEN NOT MATCHED THEN
            INSERT (lot_code, product_code, product_name, specification, qty, inbound_date, note, due_date, company_code, business_partner, business_code,purchase_price, remain_qty)
            VALUES (v_lotCode, #{productCode}, #{productName}, #{specification}, #{qty}, sysdate, #{note}, #{dueDate}, #{companyCode}, #{businessPartner}, #{businessCode}, #{orderPrice}, #{qty});
    END;
</update>

<!-- 출하 지시서 조회 -->
<select id="getDeliveryOrderList" resultType="ComOrderVO">
select 
       deo.do_code AS do_code, 
        SUM(dod.qty) AS amount,
       deo.cus_code AS cus_code,
       cu.cus_name AS cus_name,
       deo.ex_date AS due_date,
       CASE
         WHEN COUNT(dod.do_no) > 1 
             THEN COALESCE(MIN(prd.product_name), '제품명미등록') || ' 외 ' || (COUNT(dod.do_no) - 1) || '건'
        ELSE COALESCE(MIN(prd.product_name), '제품명미등록') 
       END as product_name
from delivery_order deo
JOIN do_detail dod 
ON deo.do_no = dod.do_no
LEFT JOIN product prd
ON dod.product_code = prd.product_code
JOIN customer cu
ON deo.cus_code = cu.cus_code
WHERE deo.do_status = '작성완료'
GROUP BY deo.do_code ,
       dod.qty ,
       deo.cus_code ,
       cu.cus_name ,
       deo.ex_date 
ORDER BY deo.ex_date

</select>
<select id="getComOrderDetailList" resultType="ComOrderDetailVO" parameterType="String">
SELECT 
        deo.do_no AS do_no
       ,dod.product_code AS product_code
       ,prd.product_name AS product_name
       ,prd.specification AS specification
       ,dod.qty AS amount 
       ,deo.ex_date AS due_date
FROM do_detail dod
JOIN product prd
ON dod.product_code = prd.product_code
JOIN delivery_order deo
ON deo.do_no = dod.do_no
WHERE deo.do_code = #{doCode}

</select>


<select id="selectAvailableLots" resultType="InboundVO">
    SELECT 
           lot_code, 
           qty, 
           inbound_date, 
           product_code 
    FROM inbound 
    WHERE product_code = #{productCode} 
      AND qty > 0 
    ORDER BY inbound_date 
</select>


<!-- 출고 등록 - 헤더 -->
<insert id="insertOutbound" parameterType="OutboundHeaderVO">
 <!-- BEFORE: insert 전에 outbHeaderCode 생성 -->
<selectKey keyProperty="outbHeaderCode" resultType="string" order="BEFORE">
        SELECT 'OBH' || TO_CHAR(SYSDATE,'YYMMDD') || '-' || SEQ_OUTBOUND_HEADER.nextval FROM dual
</selectKey>
INSERT INTO OUTBOUND_HEADER 
(
       outb_header_code
       ,do_code
       ,due_date
       ,outbound_date
       ,business_code
       ,business_partner
       ,company_code
)
VALUES(
       #{outbHeaderCode}
       ,#{doCode}
       ,#{dueDate}
       ,#{outboundDate}
       ,#{businessCode}
       ,#{businessPartner}
       ,#{companyCode}

)

</insert>

<!-- 출고 등록 - 상세 -->
<insert id="insertOutboundDetail" parameterType="OutboundVO">
<selectKey keyProperty="outboundNo" resultType="long" order="BEFORE">
        SELECT seq_outbound.nextval FROM dual
</selectKey>
INSERT INTO OUTBOUND 
(
       outbound_no
       ,product_name
       ,product_code
       ,specification
       ,qty
       ,outb_header_code
       ,company_code
)
VALUES(
       #{outboundNo}
       ,#{productName}
       ,#{productCode}
       ,#{specification}
       ,#{qty}
       ,#{outbHeaderCode}
       ,#{companyCode}
)
</insert>

<!-- 제품별 LOT 출고 등록 -->
<insert id="insertLotOutbound" parameterType="LotOutboundVO">
INSERT INTO lot_outbound
(
       LOT_OUT_NO
       ,LOT_OUT_AMT
       ,LOT_CODE
       ,OUTBOUND_NO
       ,COMPANY_CODE
)
VALUES
(
       seq_lot_outbound.nextval
       ,#{lotOutAmt}
       ,#{lotCode}
       ,#{outboundNo}
       ,#{companyCode}
)

</insert>
<!-- 
     거래명세서 조회용 쿼리
<select id="getDeliveryNote" resultMap = "deliveryResultMap">
SELECT 
       oh.outb_header_code AS outb_header_code,
       oh.outbound_date AS outbound_date,
       oh.do_code AS do_code,
       oh.business_code AS business_code,
       oh.business_partner AS business_partner,
       oh.due_date AS due_date,
       case
        when count(o.outbound_no) > 1 
            then min(o.product_name) || ' 외 ' || (count(o.outbound_no) - 1) || '건' 
        else min(o.product_name) 
    end AS product_name,
    sum(o.qty) AS qty,
    case 
        when exists (
            select 1
            FROM delivery_order do
            JOIN do_detail dod
            ON do.do_no = dod.do_no
            WHERE do.do_code = oh.do_code
        ) then 'Y'
        else 'N'
    end AS has_sheet  
FROM outbound_header oh 
JOIN outbound o
ON oh.outb_header_code = o.outb_header_code
GROUP BY oh.outb_header_code ,
       oh.outbound_date ,
       o.product_name ,
       oh.business_code ,
       oh.business_partner ,
       oh.due_date,
       oh.do_code 
ORDER BY oh.outb_header_code DESC

</select>

<resultMap id="deliveryResultMap" type="OutboundHeaderVO">
    <id property="outbHeaderCode" column="outb_header_code"/>
    <result property="doCode" column="do_code"/>
    <result property="outboundDate" column="outbound_date"/>
    <result property="businessPartner" column="business_partner"/>
    <result property="productName" column="product_name"/>
    <result property="businessPartner" column="business_partner"/>
    <result property="qty" column="qty"/>
    <result property="dueDate" column="due_date"/>
    <result property="hasSheet" column="has_sheet"/>

    <collection property="details" ofType="OutboundVO" 
        select="selectOutboundByOutbHeaderCode" column="outb_header_code"/>
</resultMap>

<select id="selectOutboundByOutbHeaderCode">
SELECT DISTINCT 
       o.product_code AS productCode,
       o.product_name AS productName,
       o.specification AS specification, 
       oh.business_code AS businessCode,
       oh.business_partner AS businessPartner,
       oh.do_code AS do_code,
       o.qty AS qty,
       oh.due_date AS dueDate,
       dod.vat_amt AS vatAmt,
       dod.sup_amt AS supAmt,
       dod.unit_price AS orderPrice,
       CASE WHEN EXISTS(select vat_amt from do_detail where do_no = (select do_no
                                                                     FROM delivery_order
                                                                     where do_code = #{doCode})
                        ) THEN 'VAT 포함'
            ELSE '면세' 
       END AS taxType
FROM outbound_header oh 
JOIN outbound o
ON oh.outb_header_code = o.outb_header_code
JOIN delivery_order do
ON do.do_code = oh.do_code
JOIN do_detail dod
ON do.do_no = dod.do_no
WHERE oh.outb_header_code = #{outCode}

</select>
 -->
 <!-- 거래명세서 조회용 쿼리 -->
<select id="getDeliveryNote" resultType="OutboundHeaderVO">
SELECT 
    oh.outb_header_code AS outbHeaderCode,
    oh.outbound_date AS outboundDate,
    oh.do_code AS doCode,
    oh.business_code AS businessCode,
    oh.business_partner AS businessPartner,
    oh.due_date AS dueDate,
    CASE
        WHEN COUNT(o.outbound_no) > 1 
            THEN MIN(o.product_name) || ' 외 ' || (COUNT(o.outbound_no) - 1) || '건'
        ELSE MIN(o.product_name)
    END AS productName,
    SUM(o.qty) AS qty,
    CASE 
        WHEN EXISTS (
            SELECT 1
            FROM delivery_order do2
            JOIN do_detail dod2 ON do2.do_no = dod2.do_no
            WHERE do2.do_code = oh.do_code
        ) THEN 'Y'
        ELSE 'N'
    END AS hasSheet
FROM outbound_header oh
JOIN outbound o ON oh.outb_header_code = o.outb_header_code
GROUP BY oh.outb_header_code, oh.outbound_date, oh.business_code,
         oh.business_partner, oh.due_date, oh.do_code
ORDER BY oh.outb_header_code DESC
</select>

<!-- 그리드 행 클릭시 출고 상세내역 조회 -->
<select id="selectOutboundByOutbHeaderCode" parameterType="string" resultType="OutboundVO">
SELECT DISTINCT 
       o.product_code AS productCode,
       o.product_name AS productName,
       o.specification AS specification,
       oh.business_code AS businessCode,
       oh.business_partner AS businessPartner,
       oh.do_code AS doCode,
       o.qty AS qty,
       oh.due_date AS dueDate,
       dod.vat_amt AS vatAmt,
       dod.sup_amt AS supAmt,
       dod.unit_price AS orderPrice,
       CASE WHEN EXISTS(
                SELECT 1 FROM do_detail d2 
                WHERE d2.do_no = (SELECT do_no FROM delivery_order WHERE do_code = #{doCode} AND vat_amt > 0)
            ) THEN 'VAT 포함'
            ELSE '면세'
       END AS taxType
FROM outbound_header oh
JOIN outbound o ON oh.outb_header_code = o.outb_header_code
JOIN delivery_order do ON do.do_code = oh.do_code
JOIN do_detail dod ON do.do_no = dod.do_no
WHERE oh.outb_header_code = #{outCode}
</select>

<!-- 이달 결산 데이터 존재여부 조회 -->
<select id="checkThisMonthSettlement"  resultType="int">
<![CDATA[
SELECT CASE WHEN EXISTS (
		        SELECT 1
		        FROM inventory_closing
		        WHERE ic_date >= TRUNC(SYSDATE,'MM')
		          AND ic_date < TRUNC(ADD_MONTHS(SYSDATE,1),'MM') 
		                   )   
	        THEN 1 
            ELSE 0 END  AS exist_data
    FROM dual
]]>
</select>

<!-- 결산 마스터(헤더) 생성 -->
<insert id="insertInvenClosing">
<selectKey keyProperty="icCode" resultType="String" order="AFTER">
<!-- 
        SELECT ic_code
        FROM inventory_closing
        WHERE company_code = #{companyCode}
          AND ic_status = 'T' 
        ORDER BY ic_date DESC
-->
SELECT ic_code
FROM (
    SELECT ic_code
    FROM inventory_closing
    WHERE company_code = #{companyCode}
      AND ic_status = 'T'
    ORDER BY ic_date DESC
)
WHERE ROWNUM = 1
</selectKey>
 INSERT INTO inventory_closing (
        ic_code,         <!-- 결산 코드 -->
        emp_id,
        ic_status,
        ic_date,
        company_code
    )
  VALUES(
       'IC'||TO_CHAR(SYSDATE ,'YYYYMMDD')
       ,#{empId}
       ,'T'
       ,TRUNC(SYSDATE)
       ,#{companyCode}
  )  
</insert>

<!-- 결산 상세(디테일) 등록 -->
<insert id="insertInvenClosingDetail">
INSERT INTO inventory_closing_detail(
      IC_DETAIL_NO
      ,INS_DATE
      ,EMP_ID
      ,DEPT_NAME
      ,PRODUCT_CODE
      ,PRODUCT_NAME
      ,OPENING_STOCK
      ,STOCK
      ,VALUATION_AMOUNT
      ,IC_CODE
      ,COMPANY_CODE
)
SELECT
      SEQ_IC_DETAIL.nextval
      ,TRUNC(sysdate)
      ,#{empId}
      ,'재고부'
      ,i.product_code
      ,i.product_name
      ,NVL(prev.opening_stock, 0) AS opening_stock   -- 이전달 이월재고
      ,i.remain_qty
      ,(i.remain_qty * i.purchase_price) AS valuation_amount
      ,#{icCode}
      ,#{companyCode} 
FROM INBOUND i
LEFT JOIN INVENTORY_CLOSING_DETAIL prev 
  ON prev.product_code = i.product_code 
 AND TRUNC(prev.ins_date, 'MM') = TRUNC(ADD_MONTHS(SYSDATE, -1), 'MM') 
</insert>

<!-- 결산 승인 서명 등록 수정 -->
<update id="updateIcSignDataByIcCode" parameterType="InvenVO">
UPDATE INVENTORY_CLOSING 
SET final_sign = #{finalSign} 
    ,emp_sign = #{empSign}  
WHERE ic_code = #{icCode}

</update>

</mapper>