<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layout/base}">
<head>
  <title layout:fragment="title">수당 등록</title>
  <th:block layout:fragment="head_extra">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community@31.3.1/styles/ag-grid.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community@31.3.1/styles/ag-theme-quartz.css"/>
    <style>
      #allowGrid.ag-theme-quartz { height: 44rem; width: 100%; margin-top: .5rem; }
      .btn-use { padding:.2rem .6rem; font-size:12px; }
    </style>
  </th:block>
</head>
<body>
<section layout:fragment="content">
  <div class="card shadow mb-3">
    <div class="card-header py-3 d-flex align-items-center justify-content-between">
      <h6 class="m-0 font-weight-bold text-primary">수당 등록</h6>
    </div>
    <div class="card-body">
      <div id="allowGrid" class="ag-theme-quartz"></div>
    </div>
  </div>
</section>

<th:block layout:fragment="body_extra">
<script src="https://cdn.jsdelivr.net/npm/ag-grid-community@31.3.1/dist/ag-grid-community.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios@1.7.7/dist/axios.min.js"></script>
<script th:inline="none">
  let gridApi;

  // 드롭다운 옵션
  const TAX_TYPES = ['전액과세','비과세','부분비과세','식대','보육수당'];
  const PAY_TYPES = ['고정','변동'];

  // 유틸
  const isBlank = (v) => v === null || v === undefined || String(v).trim() === '';
  function newInputRow(){
    return { _isInput:true, allowCode:'', allowName:'', taxType:TAX_TYPES[0], payType:PAY_TYPES[0], methodDesc:'', useYn:'Y' };
  }
  function isInsertSavable(r){ return r?._isInput && !isBlank(r.allowCode) && !isBlank(r.allowName); }
  function isUpdateSavable(r){ return !r?._isInput && !isBlank(r.allowCode) && !isBlank(r.allowName); }

  // API
  async function fetchList(){
    const { data } = await axios.get('/api/hr/allow-codes');
    return Array.isArray(data)? data : [];
  }
  async function insertRow(r){
    const payload = { allowCode:r.allowCode, allowName:r.allowName, taxType:r.taxType, payType:r.payType, methodDesc:r.methodDesc, useYn:r.useYn };
    const res = await axios.post('/api/hr/allow-codes', payload);
    return res?.data?.success === true;
  }
  async function updateRow(r){
    const payload = { allowName:r.allowName, taxType:r.taxType, payType:r.payType, methodDesc:r.methodDesc, useYn:r.useYn };
    const res = await axios.put(`/api/hr/allow-codes/${encodeURIComponent(r.allowCode)}`, payload);
    return res?.data?.success === true;
  }
  async function patchUseYn(code, yn){
	  const res = await axios.patch(`/api/hr/allow-codes/${encodeURIComponent(code)}/use-yn`, null, { params:{ useYn: yn }});
	  return (res?.data === 1) || (res?.data?.success === true);
	}

  // 사용/중지 버튼 렌더러(입력행에는 버튼 X)
  function useToggleRenderer(p){
    if (p.data?._isInput) return document.createTextNode('');
    const btn = document.createElement('button');
    btn.type = 'button';
    const cur = (p.value ?? 'Y');
    btn.className = 'btn btn-sm btn-use ' + (cur === 'Y' ? 'btn-success' : 'btn-danger');
    btn.textContent = (cur === 'Y' ? '사용' : '중지');

    btn.addEventListener('click', async () => {
      const row = p.data;
      const next = (row.useYn ?? 'Y') === 'Y' ? 'N' : 'Y';

      // 화면 즉시 반영
      row.useYn = next;
      btn.className = 'btn btn-sm btn-use ' + (next === 'Y' ? 'btn-success' : 'btn-danger');
      btn.textContent = (next === 'Y' ? '사용' : '중지');

      try{
        const ok = await patchUseYn(row.allowCode, next);
        if(!ok) throw new Error();
      }catch(e){
        // 실패 시 원복
        const prev = next === 'Y' ? 'N' : 'Y';
        row.useYn = prev;
        btn.className = 'btn btn-sm btn-use ' + (prev === 'Y' ? 'btn-success' : 'btn-danger');
        btn.textContent = (prev === 'Y' ? '사용' : '중지');
        alert('사용여부 변경에 실패했습니다.');
      }
    });

    return btn;
  }

  // 입력행을 항상 "마지막"으로 유지
  function keepInputRowAtEnd(params){
    const rows = params.nodes;
    const inputNodes = [];
    for(let i = rows.length - 1; i >= 0; i--){
      const n = rows[i];
      if(n?.data?._isInput){
        inputNodes.push(n);
        rows.splice(i, 1);
      }
    }
    // 맨 뒤로 재배치 (입력행이 여러 개 생기는 상황 방지)
    inputNodes.forEach(n => rows.push(n));
  }

  document.addEventListener('DOMContentLoaded', async () => {
    const columnDefs = [
      { headerName:'수당 항목코드', field:'allowCode', width:140,
        editable: (p)=> p.data?._isInput === true },
      { headerName:'수당 항목', field:'allowName', minWidth:160, flex:1, editable:true },
      { headerName:'비과세 유형', field:'taxType', width:140, editable:true,
        cellEditor:'agSelectCellEditor', cellEditorParams:{ values:TAX_TYPES } },
      { headerName:'지급유형', field:'payType', width:110, editable:true,
        cellEditor:'agSelectCellEditor', cellEditorParams:{ values:PAY_TYPES } },
      { headerName:'산출방법', field:'methodDesc', minWidth:240, flex:1.5, editable:true },
      { headerName:'사용 여부', field:'useYn', width:120,
        editable:(p)=> p.data?._isInput === true,
        cellEditor:'agSelectCellEditor', cellEditorParams:{ values:['Y','N'] },
        cellRenderer: useToggleRenderer
      }
    ];

    gridApi = agGrid.createGrid(document.querySelector('#allowGrid'), {
      columnDefs,
      rowData: [],
      pagination: true,
      paginationPageSize: 20,

      // 검색 안 씀: 헤더를 심플하게
      defaultColDef: { resizable:true, filter:false },

      editType: 'fullRow',
      singleClickEdit: true,
      stopEditingWhenCellsLoseFocus: true,
      sortModel: [{ colId:'allowCode', sort:'asc' }],

      // 정렬 후에도 입력행이 맨 끝에 위치하도록
      postSortRows: keepInputRowAtEnd,

      // 행 편집 종료 → 자동 저장
      onRowValueChanged: async (ev) => {
        const d = ev.data;
        try {
          if (isInsertSavable(d)) {
            // 입력행 저장
            const ok = await insertRow(d);
            if(!ok) throw new Error();

            // 전체 재조회 후 입력행을 마지막에 다시 추가
            const rows = await fetchList();
            gridApi.setGridOption('rowData', [...rows, newInputRow()]);

          } else if (isUpdateSavable(d)) {
            // 기존행 업데이트
            const ok = await updateRow(d);
            if(!ok) throw new Error();
            gridApi.refreshClientSideRowModel('sort');
          }
        } catch(err){
          console.error(err);
          alert('저장 실패: 입력값을 확인하세요.');
          // 실패 시엔 별도 원복 없이 사용자에게 재입력 유도
        }
      },

      onGridReady: async () => {
        const rows = await fetchList();
        gridApi.setGridOption('rowData', [...rows, newInputRow()]);
      }
    });
  });
</script>
</th:block>
</body>
</html>
